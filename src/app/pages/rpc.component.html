<div class="banner" style="height: 500px;">
    <div class="wrapper">
        <div class="text">
            <h1>Deepkit RPC</h1>

            <p class="banner-text">
                The fastest way to connect your frontend with your backend or interconnect your micro-services with
                automatic
                serialization, validation, error forwarding, fully typsafe interface, and streaming capabilities using RxJS
                <br/> —
                without code generation or config files, all Typescript.
            </p>

            <div class="actions">
                <a routerLink="/documentation/type" class="button primary">Get started</a>
            </div>
        </div>
    </div>
</div>


<feature-box>
    <div class="top" style="margin-bottom: 50px;">
        <h3>This is how it works</h3>
        <p>
            You write your controller interface (actions) and models (parameter and return types)
            in a shared library/package that can be imported by frontend/client and server.
        </p>
        <p>
            <strong>The server</strong> implements the interface using a simple Typescript class and decorators.<br/>
            <strong>The client</strong> consumes the interface with a client that automatically serializes
            and executes the action on the server.
        </p>
    </div>

    <div class="left">
        <div style="text-align: center">
            <h3>Frontend</h3>

            <p>Angular, React, Vue, HTML5, Node.</p>
        </div>


        <div class="box">
      <textarea codeHighlight>
import {DeepkitClient} from ‘@deepkit/rpc’;
import {MyControllerInterface} from ‘common’;

//connect via WebSockets/TCP, or in-memory for SSR
const client = new DeepkitClient(‘localhost’);
const ctrl = client.controller(MyControllerInterface);

const user = await ctrl.getUser(42);
console.log(user.username);
console.log(user instanceof User); //true
      </textarea>
        </div>
    </div>

    <div class="right">
        <div style="text-align: center">
            <h3>Server</h3>
            <p>Using Typescript classes.</p>
        </div>
        <div class="box">
      <textarea codeHighlight>
import {rpc} from ‘@deepkit/rpc’;
import {MyControllerInterface, User} from ‘common’;

@rpc.controller(MyControllerInterface)
class MyController implements MyControllerInterface {
    @rpc.action()
    async getUser(id: number): Promise<User> {
        return new User(id);
    }
}
      </textarea>
        </div>
    </div>

    <div class="mini-wrapper">

        <div style="text-align: center; margin-top: 40px;">
            <h3>Common</h3>
            <p>
                In a common package shared with backend and frontend you define
                your interface and models.
            </p>
        </div>

        <div class="box">
        <textarea codeHighlight>
@entity.name(‘user’)
export class User {
    @t username: string = ‘’;
    constructor(@t public id: number) {}
}

export MyControllerInterface = Controller<MyControllerInterface>(‘my’, [User]);
export interface MyControllerInterface {
     async getUser(id: number): Promise<User>;
}
        </textarea>
        </div>
    </div>

</feature-box>


<feature-box>
    <div class="left">
        <h2>Simple class methods</h2>
        <p>
            RPC actions are simple class methods, decorated with <code>@rpc.action()</code>.
            Parameter and return type are inferred as much as possible using Deepkit Type.
        </p>

        <p>
            Types that can't be inferred from Typescript's <code>emitDecoratorMetadata</code>
            can be manually annotated using Deepkit Type.
        </p>

        <p>
            Fully type-safe since you import the Typescript interface of your controller
            in your clients directly.
        </p>

        <p>
            You can even share your database models from Deepkit ORM and return them
            directly in your RPC action.
        </p>
    </div>

    <div class="right">
        <div class="box">
      <textarea codeHighlight>
import {rpc} from ‘@deepkit/rpc’;
import {MyControllerInterface, User} from ‘common’;

@rpc.controller(MyControllerInterface)
class MyController implements MyControllerInterface {
    // simple types can be inferred automatically
    @rpc.action()
    async getUser(id: number): Promise<User> {
        return new User(id);
    }

    // more complex types need to be annotated using @t
    // since they are not emitted by Typescript.
    @rpc.action()
    @t.map(t.number)
    async labelUser(
        id: number,
        @t.array(t.string) labels: string[]
    ): Promise<{[name: string]: number}> {
        return labels.map(v => {
            return {v: 1};
        });
    }
}
      </textarea>
        </div>
    </div>
</feature-box>


<feature-box>
    <div class="left">
        <h2>Type serialization</h2>
        <p>
            Data types of action parameters and its return type like String, Number, Boolean, Date, arrays, typed arrays,
            objects, and custom entities are serialized automatically back and forth using a flexible and fast binary protocol.
        </p>
    </div>

    <div class="right">
        <div class="box">
      <textarea codeHighlight>
class MyController implements MyControllerInterface {
    @rpc.action()
    async getUser(id: number): Promise<User> {
        return new User(id);
    }

    @rpc.action()
    hello(name: string): string {
        return 'Hello ' + name;
    }

    @rpc.action()
    async uploadFile(data: Uint8Array): Promise<boolean> {
        return true;
    }
}
      </textarea>
        </div>
    </div>
</feature-box>


<feature-box>
    <div class="left">
        <h2>Parameter validation</h2>
        <p>
            All parameters are automatically validated on the server side to make sure
            even malicious clients can't send invalid requests.
        </p>
        <p>
            Use all available validators from Deepkit Type, or write your own validation functions.
        </p>
        <p>
            When invalid parameters are sent a <code>ValidationError</code> object is thrown
            with detailed error code and message for each parameter, that
            can be nicely shown in the user interface.
        </p>
    </div>

    <div class="right">
        <div class="box">
      <textarea codeHighlight>
class MyController implements MyControllerInterface {
    @rpc.action()
    async getUser(
        @t.positive().max(100000) id: number
    ): Promise<User> {
        return new User(id);
    }

    @rpc.action()
    hello(
        @t.pattern(/[a-zA-Z0-9\-]+/) name: string
    ): string {
        return 'Hello ' + name;
    }

    @rpc.action()
    async uploadFile(
        @.maxLength(1024*1024) data: Uint8Array
    ): Promise<boolean> {
        return true;
    }
}
      </textarea>
        </div>
    </div>
</feature-box>


<feature-box>
    <div class="left">
        <h2>RxJS streaming</h2>
        <p>
            Streaming data to the client shouldn't be hard. That's why Deepkit RPC
            supports RxJS Observable, Subject, and BehaviorSubject natively.
        </p>

        <p>
            Just return a Observable in an action and the client receives an observable
            as well, that forwards all emitted values — of course automatically serialized.
        </p>

        <p>
            As soon as the client unsubscribes the Observable the same Observable
            is completed on the server side as well and triggers the <code>unsubscribe</code> callback.
        </p>

        <p>
            All Observables and subscriptions are automatically closed when the client disconnects.
        </p>

        <div class="box">
      <textarea codeHighlight>
// client
const client = new DeepkitClient(‘localhost’);
const ctrl = client.controller(MyControllerInterface);

const sensorData = await ctrl.sensorData();
const sub = sensorData.subscribe((next) => {
    console.log('sensor says', next);
});

//when done watching for data, but keeps Subject
//on server alive, for other subscribers.
sub.unsubscribe();

const chat = await ctrl.getChatChannel('general');
chat.subscribe((next) => {
    console.log('sensor says', next);
});

//completes the whole Subject, triggering its TearDown
chat.unsubscribe();
      </textarea>
        </div>

    </div>

    <div class="right">
        <div class="box">
      <textarea codeHighlight>
// server
class MyController implements MyControllerInterface {
    protected sensorData = new Subject<number>();

    @rpc.action()
    sensorData(): Subject<number> {
        // return already existing subjects
        return sensorData;
    }

    @rpc.action()
    getChatChannel(
        name: string
    ): Subject<{user: string, message: string} {
        const subject = new Subject();

        const interval = setInterval(() => {
            subject.next({
                user: 'bot', message: 'It is time!'
            });
        });
        //add tearDown function, when client closes
        subject.subscribe().add(() => {
            clearInterval(interval);
        });

        return subject;
    }

    @rpc.action()
    async subscribeNumbers(): Observable<number> {
        return new Observable((observer) => {
          console.log('new subscription!');
          observer.next(42);

          return {unsubscribe() {
            console.log('subscription ended');
          }};
        });
    }
}
      </textarea>
        </div>
    </div>
</feature-box>


<feature-box>
    <div class="left">
        <h2>Error forwarding</h2>
        <p>
            If an error is throwing in an action on the server,
            it is automatically serialized and forwarded to the client.
        </p>

        <p>
            Custom error classes can also be used the same as with
            custom entity classes.
        </p>

        <div class="box">
      <textarea codeHighlight>
//client.ts
const client = new DeepkitClient(‘localhost’);
const ctrl = client.controller(MyControllerInterface);

try {
    const sensorData = await ctrl.sensorData();
} catch (error) {
    error.message === 'No sensor with name ...';
}

try {
    await ctrl.customError();
} catch (error) {
    error instanceof MyCustomError; //true
}

      </textarea>
        </div>
    </div>

    <div class="right">
        <div class="box" style="margin-bottom: 25px;">
      <textarea codeHighlight>
//common.ts
@entity.name('@error/my-custom')
class MyCustomError extends Error {
    @t.array(t.string) codes: string[] = [];
}
      </textarea>
        </div>

        <div class="box">
      <textarea codeHighlight>
//server.ts
class MyController implements MyControllerInterface {
    @rpc.action()
    getSensorData(name: string): Subject<number> {
        if (name === 'temp') return this.tempSensor;
        throw new Error(`No sensor ${name}`);
    }

    @rpc.action()
    customError(): string {
        const error = new MyCustomError();
        error.codes = ['a', 'b'];
        throw error;
    }
}
      </textarea>
        </div>
    </div>
</feature-box>


<feature-box>
    <div class="left">
        <h2>Download/Upload progress</h2>
        <p>
            Bigger packages are chunked automatically and allow you to monitor the upload and download progress.
        </p>

        <div class="box">
      <textarea codeHighlight>
//client.ts
const client = new DeepkitClient(‘localhost’);
const ctrl = client.controller(MyControllerInterface);

const progress = ClientProgress.track();
progress.upload.subscribe(progress => {
    console.log('upload progress',
        progress.upload.total, progress.current,);
});
await ctrl.uploadFile(new Uint8Array(1024*1024));

const progress2 = ClientProgress.track();
progress2.download.subscribe(progress => {
    console.log('download progress',
        progress2.download.total, progress2.download.current,
    );
});
const zip = await ctrl.downloadFile('file.zip');

      </textarea>
        </div>
    </div>

    <div class="right">
        <div class="box">
      <textarea codeHighlight>
//server.ts
class MyController implements MyControllerInterface {
    @rpc.action()
    uploadFile(data: Uint8Array): Promise<boolean> {
        return true;
    }

    @rpc.action()
    downloadFile(path: string): Promise<Uint8Array> {
        return new Uint8Array(1024*1024);
    }
}
      </textarea>
        </div>
    </div>
</feature-box>


<feature-box color="#3e3e3e">
    <div class="left">
        <h2>High-Performance</h2>
        <p>
            A carefully optimized binary protocol, serializer and decoder for the v8 engine
            as well as light abstraction enables very high ops/second with efficiency memory usage.
        </p>
        <a class="button">Learn more</a>
    </div>

    <div class="right">
        <performance-chart yAxis="ops/second via TCP" sort="asc" format="0.0-0">
            <performance-entry title="gRPC-js" [value]="7536"></performance-entry>
            <performance-entry title="Deepkit RPC" [value]="34320"></performance-entry>
        </performance-chart>
    </div>
</feature-box>
